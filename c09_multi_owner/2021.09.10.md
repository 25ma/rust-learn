2021.09.10
    今天是教师节，一上午就看了陈天老师的专栏课程，然后学习了rust 所有权 Rc 引用计数， 以及 refcell 内部可变借用
    同时还了解到了Box::leak 的机制,  Box 是rust下的智能指针, 可以强制吧任何数据结构创建在堆上，然后在栈上放一个指针指向这个数据结构,
    但这个时候的生命周期还是受rust 所有权机制控制，跟栈上的指针一致。然后，Box::leak(), 它创建的对象，从堆内存上泄露出去，不受栈内存的控制，是一个自由的，生命周期可以大到和整个进程的生命周期一致的对象。 虽然有这个特性，
    但是我们可以用这个做什么事情呢？    
        - 1. 通过这个方式实现了最小所有权原则，最大程度帮助开发者撰写安全的rust 程序
    以及会有什么隐患？（后续再来补充，目前不清楚）

    ##### Rc
        - Rc是rust 的一个引用计数，但是在多线程访问的时候，并不是线程安全的，所以需要使用Arc 来做线程安全

    ##### Arc
        - Arc 就相当于是 Rc 前面加了 Atomic (原子性), 也就是使用原子性保证了线程安全的操作，其底层不同之处就是， Rc 计数类型是 usize , 而 Arc 的计数是通过 Atomic Usize, 使用了CPU的特殊指令来保证多线程下的安全 （至于是什么指令这个我目前也不清楚）

    对了 通过查看老师的代码，我学会了 原来在Cargo.toml 里面配置多个[[bin]] 可以单独进行测试运行， 比如 cargo run --bin 二进制包名 非常适合学习些一些小的demo的程序。